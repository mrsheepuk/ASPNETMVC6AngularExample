<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="../stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="../stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Part 3 - ASP.NET MVC6 Angular Tutorial by mrsheepuk</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>ASP.NET MVC6 Angular Tutorial</h1>
          <h2>Basic ASP.NET 5 MVC6 Angular tutorial with easy gulp tooling.</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/mrsheepuk/ASPNETMVC6AngularExample" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>Part 3: Creating and consuming a service</h1>

          <p>This continues on from the work done in <a href="../part02/">part 2</a>,
            if you haven't completed that, it's best to head over there. Alternatively,
            you can switch to the branch "Part02Final" (Team Explorer - Branches - right
            click "Part02Final" inside remotes/origin and select "New local branch from..."
            and give it a local name, tick Checkout branch and untick Track remote branch)
            to use our version of part 2.</p>

          <h2>Creating our thingList service</h2>
          
          <p>In wwwroot/js/src, create a folder named services, and in that, a Javascript 
            file named thingList.service.js. In that file, paste the following boilerplate
            starting point for our service (which, by convention, will be named with a 
            lower-case leading letter to indicate that only a single instance of this
            will ever exist):</p>
            
          <pre>(function () {
  'use strict';
  // Register our service on our module.
  angular.module('app').factory('thingListService', thingListService);

  // Inject the dependencies - we'll use the angular-provided $http 
  // service to interact with the server. 
  thingListService.$inject = ['$http']

  // Define our service - note that Angular will ensure that whatever
  // we've specified in our $inject clause above will get injected as
  // parameters here, allowing us to use that within our service.
  function thingListService($http) {
    // Define the public interface for the service here
    var service = {
    };

    // Return the interface.
    return service;

    // Define the functions referenced by the service interface
    // above here:
    
  }
})();</pre>

          <p>Here, we've registered a new, empty, service called thingListService with Angular, and declared
            that it requires the Angular-provided $http service injected into it. Now, let's use that to get
            our list of things from the server. Update the public interface to include a new function:</p>
            
          <pre>var service = {
  getThings: getThings
};</pre>

          <p>... then create the getThings function below the "return service;" line:</p>
          
          <pre>function getThings() {
  // $http.get returns a promise - when this promise resolves, we want to
  // unwrap the data from the response and return that to anything waiting
  // on this.
  return $http.get("/api/thinglist").then(
    function (response) {
      return response.data;
    }
  );
}</pre>

          <p>This basic function has touched on an important concept - a "promise" - so before we continue,
            we'll have a quick introduction to promises and how they work. We'll get back to our service shortly!</p>

          <h3>A quick word on "Promises"</h3>

          <p>In Javascript there is only a <strong>single thread of execution</strong>, therefore anything 
            which takes time to complete (such as HTTP calls to a server) can't simply wait, as the web
            browser would freeze until it returns. In such circumstances callback functions are used, 
            which provide code to be executed when an asynchronous action completes.</p>
            
          <p>"Promises" are a way of structuring callbacks in a way that allows the code to be written
            sequentially, chaining callbacks together one after another, instead of nesting callbacks inside
            each other which quickly becomes unmanagable. It also provides a standard way that calling code
            can access the final result of an asynchronous operation.</p>
            
          <p>A promise returns an object which has a function <strong>.then(fulfilledCallback, [rejectedCallback])</strong> 
            on it - into this function, you can pass one or two callback functions - and the "promise" ensures 
            that one of these (and only one) will be called exactly once at some point in future - called 
            "resolving" the promise.</p>
            
          <p>The fulfilledCallback will be executed should the promise complete successfully, and will be passed 
            the result of the operation. The rejectedCallback (if specified) will be executed should the promise
            fail (this can be for technical errors such as a timeout or functional failures such as validation
            problems), and is passed a "reason" describing the failure (which will often be a Javascript
            Error instance of some kind).</p> 
            
          <p>The .then() function itself returns another promise, allowing .thens to be chained together 
            one after another, to create a logical sequence of asynchronous operations.</p>
            
          <p>Within a fulfilledCallback or rejectedCallback, you can return a value <strong>or another 
            promise</strong>. If you return a value, any further ".then" callback which has been chained on 
            will be immediately fulfilled with the value you have returned. If you return another 
            promise, that will itself be waited upon, and once that resolves, any further ".then" callback 
            which has been chained on will be fulfilled (or rejected) with the result of that promise.</p>
            
          <p>To show the power of this, here's an admittedly unrealistic example showing multiple HTTP 
            calls being chained together, each using the response of the last:</p>
            
          <pre>function doOurHorseyThing() {
  var promise = $http.get("/api/refdata").then(
    function (refDataResponse) {
      // For some reason, we're interested in the first horse returned, 
      // so we return another promise here which will resolve with data 
      // about that horse.
      var ourHorse = refDataResponse.data.horses[0];
      console.log("We've found a horse with ID " + ourHorse.id);
      return $http.get("/api/horses/" + ourHorse.id);              
    }
  ).then(
    function (horseDataResponse) {
      // Now we've got the data for that first horse, let's create a
      // race with his name included, and return a promise for creating
      // that race.
      var horseName = horseDataResponse.data.name;
      console.log("We've loaded the horses info and found its name is "
        + horseName);
      return $http.post("/api/races", { "horseName": horseName });
    }
  ).then(
    function (raceCreatedResponse) {
      // This will be resolved once the race has been created, so let's 
      // return the response to the POST to anyone waiting on this whole
      // promise chain to complete.
      console.log("We've successfully made our race!")
      return raceCreatedResponse.data;
    }, 
    function (err) {
      // Errors bubble along the promise chain until they find a then
      // with a failureHandler specified - therefore ANY 
      // error thrown by ANY of the above asynchronous actions will 
      // find its way here. If this doesn't throw an error itself, 
      // anything chained onto the end of this will be resolved 
      // *successfully*, so you need to re-throw or fully deal with 
      // the error here.
      console.log("Failed doing our horsey thing - " + err.message);
      // Re-throw the error.
      throw err;
    }
  );
  
  // **********
  // NOTE: The next line will be executed BEFORE ANY of the callbacks
  // specified inside the .thens above! Remember it's all asynchronous
  // inside the .then()'s.
  // **********
  console.log("Request sent!");
  
  // Return the promise, so whoever called this can get access to the 
  // result of these promises once they finish resolving, or add its
  // own chain of .thens on and keep the party going!
  return promise;
}</pre>

          <p>Notice how, irrespective of how many actions we're chaining up, we're not getting
            any further "nested" as we go on - just adding .thens on to the end repeatedly. In 
            real-world usage, you're unlikely to chain them all together like this in one place, 
            more likely you'll have one or two chained together then return that promise to
            somewhere else, where you might add another "then" on the end, and so on! By using
            promises everywhere, buildling up sequences of asynchronous operations becomes 
            <em>relatively</em> straightforward.</p>

          <p>To compare, if you were using "standard" callback nesting, that same code would
            look like this - note how we're getting further and further nested as we go on 
            (and just imagine if we added a couple more actions on the end!). Also
            note how we're having to provide multiple error handlers for the different levels 
            of nesting:</p>
            
          <em>For the purposes of the below, assume $http.get and $http.post take success and
            failure callbacks as parameters; this <strong>is not the case</strong> so this code 
            would not actually work.</em>

          <pre>function doOurHorseyThing(callbackWhenFinished, callbackIfFailed) {
  $http.get("/api/refdata", 
    function (refDataResponse) {
      // For some reason, we're interested in the first horse returned, 
      // so load the data about that horse.
      var ourHorse = refDataResponse.data.horses[0];
      console.log("We've found a horse with ID " + ourHorse.id);
      $http.get("/api/horses/" + ourHorse.id, 
        function (horseDataResponse) {
          // Now we've got the data for that first horse, let's create a
          // race with his name included
          var horseName = horseDataResponse.data.name;
          console.log("We've loaded the horses info and found his name is "
            + horseName);
          $http.post("/api/races", { "horseName": horseName }, 
            function (raceCreatedResponse) {
              // This will be called once the race has been created, so let's 
              // call the callback we were passed with the response for 
              // creating the race.
              console.log("We've successfully made our race!")
              callbackWhenFinished(raceCreatedResponse.data);
            },
            function (raceCreatedError) {
              // Do any specific error handling, or simply
              // call the failure callback.
              callbackIfFailed(raceCreatedError);
            }
          );
        },
        function (horseDataError) {
          // Do any specific error handling, or simply
          // call the failure callback.
          callbackIfFailed(horseDataError);
        }
      );              
    }, 
    function (refDataError) {
      // Do any specific error handling, or simply
      // call the failure callback.
      callbackIfFailed(refDataError);
    }
  );

  // **********
  // NOTE: The next line will be executed BEFORE ANY of the callbacks
  // specified above! Remember it's all asynchronous inside the
  // callbacks.
  // **********
  console.log("Request sent!");
}</pre>

          <p>We'll be using promises while creating our services, so you can play with them
            more as we go - they can be confusing at first but once you get your head around
            them, they become second nature... nearly! :)</p>
            
          <p>The promise is documented as the <a href="https://promisesaplus.com/" target="_blank">Promises/A+ 
          open standard</a>, and they will become a native part of Javascript in future versions
          of the language.</p>
            
          <p>Now, back to our new service...</p>

          <h3>Wiring our service to our controller</h3>
          
          <p>Now we've got a basic service with one function on it, let's use that from our 
            controller. Open up Home.controller.js and ensure our new service gets injected
            by adding it to the $inject array (remembering that you specify the name of the
            service by a string, which must equal that used when we registered our service
            with the module), and as a parameter to the top-level controller function.</p>
            
          <p>TBC</p>

        </section>

        <footer>
          ASP.NET MVC6 Angular Tutorial is maintained by <a href="https://github.com/mrsheepuk">mrsheepuk</a><br>
          This page was generated by <a href="https://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>


      </div>
    </div>
  </body>
</html>
